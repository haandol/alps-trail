# ALPS Document

## 섹션 1. 개요

### 1.1 목적

이 문서는 ALPS 문서의 섹션 6(피쳐 수준 명세)을 입력으로 받아 실행 가능한 구현 태스크로 분해하는 CLI 도구의 개발 명세를 정의합니다. 이 도구는 structured planner를 통해 DAG(Directed Acyclic Graph)를 생성하고, 이를 기반으로 태스크 목록을 YAML 형식으로 생성하여 개발자가 로컬에서 관리할 수 있게 합니다.

### 1.2 문서명

ALPS Trail (Task Refinement and Iterative ALignment) 개발 명세서

---

## 섹션 2. MVP 목표 및 핵심 지표

### 2.1 목적

- ALPS 문서의 피쳐 명세를 분석하여 구현 가능한 태스크로 자동 분해하는 기능을 검증
- 개발자의 태스크 계획 시간을 50% 이상 단축
- 에이전트를 이용한 피쳐 구현시 에이전트의 오류생성 및 디버깅 성공률 증가

### 2.2 핵심 성과 지표(KPI)

1. 태스크 계획 시간 단축: 기존 수동 방식 대비 태스크 계획 시간 50% 이상 단축
2. 태스크 완성도: 자동 생성된 태스크의 90% 이상이 추가 수정 없이 사용 가능
3. 에이전트 오류 수정률: 에이전트가 생성된 태스크를 기반으로 코드 구현 시 오류 수정률 90% 증가

### 2.3 데모 시나리오

1. 개발자 Alex가 새로운 웹 애플리케이션의 ALPS 문서를 받았습니다.
2. Alex는 CLI 도구를 실행하여 ALPS 문서를 입력합니다.
3. 도구는 ALPS 문서의 섹션 6을 분석하여 DAG를 생성합니다.
4. 생성된 DAG를 기반으로 구현 태스크 목록이 YAML 형식으로 출력됩니다.
5. CLI 에서는 아스키 테이블 형태로 태스크 목록을 볼 수 있습니다. (Claude Taskmaster 와 비슷한 형태)
6. 개발자는 태스크 목록을 검토하고, 복잡도가 높은 태스크를 분해하여 더 작은 태스크로 분해합니다.

---

## 섹션 3. 요구사항 요약

### 3.1 핵심 기능 요구사항

- F1: ALPS 문서 파싱 및 섹션 6 추출
- F2: 피쳐 및 유저 스토리 분석
- F3: DAG(Directed Acyclic Graph) 생성 및 의존성 관리
- F4: 태스크 분해 및 생성
- F5: YAML 형식의 태스크 목록 출력

### 3.2 비기능적 요구사항

- NF1: 성능 - 일반적인 ALPS 문서(10-15개 피쳐) 처리 시 3분 이내 응답
- NF2: 사용성 - 명확한 CLI 인터페이스 및 도움말 제공
- NF3: 확장성 - 새로운 태스크 템플릿 추가 가능
- NF4: 신뢰성 - 잘못된 입력에 대한 적절한 오류 처리

---

## 섹션 4. 고수준 아키텍처

### 4.1 간단한 시스템 다이어그램

```
+------------------+     +------------------+     +------------------+
|                  |     |                  |     |                  |
|  ALPS 문서 입력  | --> |  마크다운 파서   | --> |  LLM 분석 엔진   |
|  (마크다운)      |     |  (regex)         |     |  (Claude 4)    |
|                  |     |                  |     |                  |
+------------------+     +------------------+     +------------------+
                                                          |
                                                          v
+------------------+     +------------------+     +------------------+
|                  |     |                  |     |                  |
|  YAML 출력 생성  | <-- |  태스크 포맷터   | <-- |  DAG 생성기      |
|                  |     |                  |     |  (LangGraph)     |
+------------------+     +------------------+     +------------------+
```

### 4.2 기술 스택

- 프로그래밍 언어: Python
- 문서 파싱: 마크다운 파서 (regex 기반)
- LLM 통합: Amazon Bedrock의 Claude Sonnet 4
- LLM 프레임워크: LangChain, LangGraph
- 데이터 직렬화: PyYAML

---

## 섹션 5. 디자인 명세

### 5.1 화면 구조 및 사용자 흐름

#### 5.1.1 주요 화면 (CLI 인터페이스)

CLI 도구이므로 주요 명령어 인터페이스를 정의하겠습니다:

1. 도움말 화면 (--help)
2. ALPS 문서 처리 명령 (process)
3. 결과 출력 옵션 (--output)
4. 상세 로그 옵션 (--verbose)

#### 5.1.2 화면 네비게이션

CLI 도구의 기본 사용 흐름:

1. 사용자가 도구를 실행하고 ALPS 문서 경로를 제공합니다.
2. 도구는 문서를 파싱하고 분석 진행 상황을 표시합니다.
3. DAG 생성 및 태스크 분해 과정이 진행됩니다.
4. 결과 YAML 파일이 생성되고 경로가 표시됩니다.

### 5.2 페이지 레이아웃

#### 5.2.1 CLI 출력 형식

Corba 기능을 이용하여 ASCII 테이블 형태로 태스크 목록을 보여줍니다.

### 5.3 반응형 디자인 가이드라인

CLI 도구이므로 반응형 디자인은 해당되지 않습니다. 대신 다양한 터미널 환경에서의 호환성을 고려합니다:

- 다양한 터미널 크기에 맞는 출력 포맷
- 색상 지원 및 비지원 터미널 모두 고려
- 진행 상황 표시를 위한 프로그레스 바 구현

---

## 섹션 6. 기능 수준 명세

### 6.1 ALPS 문서 파싱 및 섹션 6 추출 (F1)

#### 6.1.1 사용자 스토리

개발자로서, 나는 ALPS 문서에서 섹션 6(기능 수준 명세)을 자동으로 추출하고 싶다. 그래서 수동으로 문서를 검색할 필요 없이 필요한 정보만 빠르게 얻을 수 있다.

#### 6.1.2 UI 흐름

1. 사용자가 CLI 명령어로 ALPS 문서 경로를 제공합니다.
2. 도구는 파일을 읽고 섹션 6을 찾습니다.
3. 추출 진행 상황이 터미널에 표시됩니다.
4. 성공적으로 추출되면 확인 메시지가 표시됩니다.

#### 6.1.3 기술적 설명

1. 파일 처리
   - 마크다운 파일을 읽고 텍스트로 변환
   - 파일 인코딩 및 형식 검증

2. 섹션 6 추출
   - `---` 패턴을 기준으로 구분해서 섹션 파싱
   - 5, 6, 7 번째 섹션에서 6 이 포함된 섹션을 섹션 6으로 인식하여 추출

3. 오류 처리
   - 파일이 존재하지 않을 경우 적절한 오류 메시지 표시
   - 섹션 6을 찾을 수 없을 경우 사용자에게 알림

### 6.2 피쳐 및 유저 스토리 분석 (F2)

#### 6.2.1 사용자 스토리

개발자로서, 나는 추출된 피쳐와 유저 스토리를 자동으로 분석하여 핵심 구현 요소를 식별하고 싶다. 그래서 각 피쳐의 복잡성과 구현 요구사항을 더 잘 이해할 수 있다.

#### 6.2.2 UI 흐름



1. 도구는 추출된 섹션 6 데이터를 LLM에 전달합니다.
2. 분석 진행 상황이 터미널에 표시됩니다.
3. 각 피쳐별 분석 결과가 요약되어 표시됩니다.

#### 6.2.3 기술적 설명

1. LLM 프롬프트 생성
   - 추출된 피쳐 데이터를 구조화된 프롬프트로 변환
   - 유저 스토리, UI 흐름, 기술적 설명 등을 포함

2. 섹션 6 에서 Feature 추출
   - 각 서브 섹션 (6.1, 6.2) 가 Feature 명세를 포함하고 있음
   - `###` 이 포함된 행을 기준으로 서브 섹션 파싱

3. Claude 4 호출
   - Amazon Bedrock API를 통해 Claude Sonnet 4 모델 호출
   - 적절한 파라미터(온도, 최대 토큰 등) 설정

4. 응답 파싱
   - LLM 응답을 구조화된 데이터로 변환
   - 핵심 구현 요소, 복잡성, 의존성 등 추출

5. 분석 결과 저장
   - 각 피쳐별 분석 결과를 중간 데이터 구조에 저장
   - 다음 단계(DAG 생성)를 위한 준비

### 6.3 DAG(Directed Acyclic Graph) 생성 및 의존성 관리 (F3)

#### 6.3.1 사용자 스토리

개발자로서, 나는 분석된 피쳐와 태스크들 간의 의존성을 시각화하는 DAG를 생성하고 싶다. 그래서 구현 순서와 병렬화 가능한 작업을 쉽게 파악하고 최적의 개발 계획을 수립할 수 있다.

#### 6.3.2 UI 흐름

1. 도구는 분석된 피쳐 데이터를 기반으로 DAG를 생성합니다.
2. 생성 진행 상황이 터미널에 표시됩니다.
3. DAG 생성이 완료되면 최적 구현 순서와 병렬 작업 그룹 등의 요약 정보가 표시됩니다.

#### 6.3.3 기술적 설명

1. LangGraph 에이전트 워크플로우 구성
   - 피쳐 분석 에이전트, 의존성 분석 에이전트, 태스크 분해 에이전트 등 여러 에이전트로 구성된 워크플로우 설계
   - 각 에이전트는 Claude 4을 활용하여 특정 역할 수행
   - 에이전트 간 상태 및 결과 공유를 위한 메모리 구성

2. 의존성 분석 에이전트
   - 피쳐 분석 결과를 입력으로 받아 의존성 관계 추출
   - 순환 의존성 검사 및 해결 로직 구현
   - 의존성 그래프의 초기 구조 생성

3. DAG 구조화 에이전트
   - 의존성 분석 결과를 바탕으로 실제 DAG 데이터 구조 생성
   - 노드(피쳐 및 태스크)와 엣지(의존성) 정의
   - 최적 구현 순서 및 병렬화 가능 작업 식별

4. 결과 통합 및 최적화
   - 생성된 DAG 구조 검증 및 최적화
   - 다음 단계(태스크 분해)를 위한 데이터 준비

### 6.4 태스크 분해 및 생성 (F4)

#### 6.4.1 사용자 스토리

개발자로서, 나는 각 피쳐를 구체적인 구현 태스크로 분해하고 싶다. 그래서 작업을 더 작고 관리하기 쉬운 단위로 나누어 효율적으로 개발할 수 있다.

#### 6.4.2 UI 흐름

1. 도구는 DAG를 기반으로 각 피쳐를 태스크로 분해합니다.
2. 분해 진행 상황이 터미널에 표시됩니다.
3. 태스크 생성이 완료되면 요약 정보가 표시됩니다.

#### 6.4.3 기술적 설명

1. 태스크 분해 에이전트 구성
   - LangGraph 워크플로우 내에서 태스크 분해 담당 에이전트 설계
   - Claude 3.7을 활용한 지능적 태스크 분해 로직 구현

2. 피쳐별 태스크 생성
   - 각 피쳐의 유저 스토리, UI 흐름, 기술적 설명을 분석
   - 구현에 필요한 세부 태스크 식별
   - 각 태스크에 대한 설명, 예상 소요 시간, 난이도 등 정의

3. 태스크 의존성 설정
   - 태스크 간 의존성 관계 분석 및 설정
   - 태스크 레벨의 DAG 확장 및 세분화

4. 태스크 우선순위 지정
   - 구현 중요도 및 순서에 따른 우선순위 지정
   - 병렬 작업 가능성 고려

### 6.5 YAML 형식의 태스크 목록 출력 (F5)

#### 6.5.1 사용자 스토리

개발자로서, 나는 생성된 태스크 목록을 YAML 형식으로 출력하고 싶다. 그래서 이를 로컬 태스크 관리 도구나 다른 시스템에서 쉽게 활용할 수 있다.

#### 6.5.2 UI 흐름

1. 도구는 생성된 태스크 목록을 YAML 형식으로 변환합니다.
2. 변환 진행 상황이 터미널에 표시됩니다.
3. 출력 파일 경로가 사용자에게 표시됩니다.

#### 6.5.3 기술적 설명

1. YAML 변환 로직
   - 태스크 객체를 YAML 형식으로 직렬화
   - 계층적 구조 유지 (피쳐 > 태스크)
   - 가독성을 위한 포맷팅 적용

2. 출력 파일 생성
   - 사용자 지정 경로 또는 기본 경로에 YAML 파일 생성
   - 파일 쓰기 권한 확인 및 오류 처리

3. 출력 형식 최적화
   - 다양한 태스크 관리 도구와의 호환성 고려
   - 필요한 메타데이터 포함

4. 요약 정보 생성
   - 총 피쳐 수, 태스크 수, 예상 개발 시간 등 계산
   - 터미널에 요약 정보 표시

---

## 섹션 7. MVP 지표

### 7.1 수집할 데이터

MVP의 성공을 측정하기 위해 다음과 같은 데이터를 수집합니다:

1. **태스크 계획 시간 측정**
   - 기존 수동 방식 대비 태스크 계획 시간 측정
   - 사용자 피드백을 통한 시간 절약 정도 평가

2. **태스크 완성도 측정**
   - 자동 생성된 태스크 중 추가 수정 없이 사용 가능한 태스크의 비율
   - 사용자 피드백을 통한 태스크 품질 평가

3. **에이전트 오류 수정률 측정**
   - 에이전트가 생성된 태스크를 기반으로 코드 구현 시 오류 수정률
   - 기존 방식 대비 오류 수정 효율성 비교

4. **도구 사용성 측정**
   - 명령어 실행 횟수 및 패턴
   - 오류 발생 빈도 및 유형
   - 사용자 피드백 및 만족도

### 7.2 성공 기준

MVP의 성공 기준은 다음과 같습니다:

1. **태스크 계획 시간 단축**: 기존 수동 방식 대비 태스크 계획 시간 50% 이상 단축
   - 측정 방법: 사용자 설문 및 작업 시간 로깅
   - 목표 값: 50% 이상 시간 단축

2. **태스크 완성도**: 자동 생성된 태스크의 90% 이상이 추가 수정 없이 사용 가능
   - 측정 방법: 사용자 피드백 및 태스크 수정률 추적
   - 목표 값: 90% 이상 사용 가능

3. **에이전트 오류 수정률**: 에이전트가 생성된 태스크를 기반으로 코드 구현 시 오류 수정률 90% 증가
   - 측정 방법: 에이전트 로그 분석 및 오류 수정 성공률 비교
   - 목표 값: 오류 수정률 90% 증가

4. **사용자 만족도**: 사용자의 80% 이상이 도구를 계속 사용할 의향이 있음
   - 측정 방법: 사용자 설문 및 인터뷰
   - 목표 값: 80% 이상 재사용 의향

---

## 섹션 8. 범위 외

다음 기능들은 현재 MVP 범위에 포함되지 않으며, 향후 버전에서 구현될 예정입니다:

### 8.1 향후 개발 기능

1. **웹 인터페이스**
   - 브라우저 기반 UI를 통한 ALPS 문서 업로드 및 태스크 생성
   - 태스크 시각화 및 편집 기능

2. **통합 기능**
   - JIRA, Trello, Asana 등 프로젝트 관리 도구와의 직접 통합
   - GitHub, GitLab 등 코드 저장소와의 연동

3. **고급 분석 기능**
   - 코드 복잡도 예측 및 리소스 할당 추천
   - 유사 프로젝트 기반 개발 시간 예측

4. **MCP 통합**
   - Model Context Protocol을 통한 에이전틱 IDE들과의 통합
   - 코드 컨텍스트 공유 및 지능형 태스크 관리

### 8.2 기술적 부채

1. **성능 최적화**
   - 대규모 ALPS 문서 처리 시 메모리 사용량 최적화
   - LLM API 호출 최소화를 위한 캐싱 전략

